// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tcc_coordinator.proto

/*
	Package tcc_coordinator is a generated protocol buffer package.

	It is generated from these files:
		tcc_coordinator.proto

	It has these top-level messages:
		TransactionId
		TransactionStep
		Transaction
		BeginTransRequest
		BeginTransResponse
		TryStepRequest
		TryStepResponse
		ConfirmTransRequest
		ConfirmTransResponse
		CancelTransRequest
		CancelTransResponse
		GetTransRequest
		GetTransResponse
*/
package tcc_coordinator

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Transaction_TransactionStatus int32

const (
	Transaction_Init        Transaction_TransactionStatus = 0
	Transaction_Committed   Transaction_TransactionStatus = 10
	Transaction_RollingBack Transaction_TransactionStatus = 20
	Transaction_RolledBack  Transaction_TransactionStatus = 40
)

var Transaction_TransactionStatus_name = map[int32]string{
	0:  "Init",
	10: "Committed",
	20: "RollingBack",
	40: "RolledBack",
}
var Transaction_TransactionStatus_value = map[string]int32{
	"Init":        0,
	"Committed":   10,
	"RollingBack": 20,
	"RolledBack":  40,
}

func (x Transaction_TransactionStatus) String() string {
	return proto.EnumName(Transaction_TransactionStatus_name, int32(x))
}
func (Transaction_TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTccCoordinator, []int{2, 0}
}

type TransactionId struct {
	AppId   string `protobuf:"bytes,1,opt,name=appId,proto3" json:"appId,omitempty"`
	BusCode string `protobuf:"bytes,2,opt,name=busCode,proto3" json:"busCode,omitempty"`
	TrxId   string `protobuf:"bytes,3,opt,name=trxId,proto3" json:"trxId,omitempty"`
}

func (m *TransactionId) Reset()                    { *m = TransactionId{} }
func (m *TransactionId) String() string            { return proto.CompactTextString(m) }
func (*TransactionId) ProtoMessage()               {}
func (*TransactionId) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{0} }

func (m *TransactionId) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *TransactionId) GetBusCode() string {
	if m != nil {
		return m.BusCode
	}
	return ""
}

func (m *TransactionId) GetTrxId() string {
	if m != nil {
		return m.TrxId
	}
	return ""
}

type TransactionStep struct {
	StepId string   `protobuf:"bytes,1,opt,name=stepId,proto3" json:"stepId,omitempty"`
	Args   [][]byte `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty"`
}

func (m *TransactionStep) Reset()                    { *m = TransactionStep{} }
func (m *TransactionStep) String() string            { return proto.CompactTextString(m) }
func (*TransactionStep) ProtoMessage()               {}
func (*TransactionStep) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{1} }

func (m *TransactionStep) GetStepId() string {
	if m != nil {
		return m.StepId
	}
	return ""
}

func (m *TransactionStep) GetArgs() [][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

type Transaction struct {
	TransactionId *TransactionId                `protobuf:"bytes,1,opt,name=transactionId" json:"transactionId,omitempty"`
	Steps         []*TransactionStep            `protobuf:"bytes,2,rep,name=steps" json:"steps,omitempty"`
	Status        Transaction_TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=softtrans.contract.tcc_coordinator.Transaction_TransactionStatus" json:"status,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{2} }

func (m *Transaction) GetTransactionId() *TransactionId {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

func (m *Transaction) GetSteps() []*TransactionStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Transaction) GetStatus() Transaction_TransactionStatus {
	if m != nil {
		return m.Status
	}
	return Transaction_Init
}

type BeginTransRequest struct {
	TransactionId *TransactionId `protobuf:"bytes,1,opt,name=transactionId" json:"transactionId,omitempty"`
}

func (m *BeginTransRequest) Reset()                    { *m = BeginTransRequest{} }
func (m *BeginTransRequest) String() string            { return proto.CompactTextString(m) }
func (*BeginTransRequest) ProtoMessage()               {}
func (*BeginTransRequest) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{3} }

func (m *BeginTransRequest) GetTransactionId() *TransactionId {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

type BeginTransResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *BeginTransResponse) Reset()                    { *m = BeginTransResponse{} }
func (m *BeginTransResponse) String() string            { return proto.CompactTextString(m) }
func (*BeginTransResponse) ProtoMessage()               {}
func (*BeginTransResponse) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{4} }

func (m *BeginTransResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type TryStepRequest struct {
	TransactionId *TransactionId `protobuf:"bytes,1,opt,name=transactionId" json:"transactionId,omitempty"`
	StepId        string         `protobuf:"bytes,2,opt,name=stepId,proto3" json:"stepId,omitempty"`
	Args          [][]byte       `protobuf:"bytes,3,rep,name=Args" json:"Args,omitempty"`
}

func (m *TryStepRequest) Reset()                    { *m = TryStepRequest{} }
func (m *TryStepRequest) String() string            { return proto.CompactTextString(m) }
func (*TryStepRequest) ProtoMessage()               {}
func (*TryStepRequest) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{5} }

func (m *TryStepRequest) GetTransactionId() *TransactionId {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

func (m *TryStepRequest) GetStepId() string {
	if m != nil {
		return m.StepId
	}
	return ""
}

func (m *TryStepRequest) GetArgs() [][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

type TryStepResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
	StepId      string       `protobuf:"bytes,2,opt,name=stepId,proto3" json:"stepId,omitempty"`
}

func (m *TryStepResponse) Reset()                    { *m = TryStepResponse{} }
func (m *TryStepResponse) String() string            { return proto.CompactTextString(m) }
func (*TryStepResponse) ProtoMessage()               {}
func (*TryStepResponse) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{6} }

func (m *TryStepResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func (m *TryStepResponse) GetStepId() string {
	if m != nil {
		return m.StepId
	}
	return ""
}

type ConfirmTransRequest struct {
	TransactionId *TransactionId `protobuf:"bytes,1,opt,name=transactionId" json:"transactionId,omitempty"`
}

func (m *ConfirmTransRequest) Reset()         { *m = ConfirmTransRequest{} }
func (m *ConfirmTransRequest) String() string { return proto.CompactTextString(m) }
func (*ConfirmTransRequest) ProtoMessage()    {}
func (*ConfirmTransRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTccCoordinator, []int{7}
}

func (m *ConfirmTransRequest) GetTransactionId() *TransactionId {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

type ConfirmTransResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *ConfirmTransResponse) Reset()         { *m = ConfirmTransResponse{} }
func (m *ConfirmTransResponse) String() string { return proto.CompactTextString(m) }
func (*ConfirmTransResponse) ProtoMessage()    {}
func (*ConfirmTransResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTccCoordinator, []int{8}
}

func (m *ConfirmTransResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type CancelTransRequest struct {
	TransactionId *TransactionId `protobuf:"bytes,1,opt,name=transactionId" json:"transactionId,omitempty"`
}

func (m *CancelTransRequest) Reset()                    { *m = CancelTransRequest{} }
func (m *CancelTransRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelTransRequest) ProtoMessage()               {}
func (*CancelTransRequest) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{9} }

func (m *CancelTransRequest) GetTransactionId() *TransactionId {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

type CancelTransResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *CancelTransResponse) Reset()         { *m = CancelTransResponse{} }
func (m *CancelTransResponse) String() string { return proto.CompactTextString(m) }
func (*CancelTransResponse) ProtoMessage()    {}
func (*CancelTransResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTccCoordinator, []int{10}
}

func (m *CancelTransResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type GetTransRequest struct {
	TransactionId *TransactionId `protobuf:"bytes,1,opt,name=transactionId" json:"transactionId,omitempty"`
}

func (m *GetTransRequest) Reset()                    { *m = GetTransRequest{} }
func (m *GetTransRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTransRequest) ProtoMessage()               {}
func (*GetTransRequest) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{11} }

func (m *GetTransRequest) GetTransactionId() *TransactionId {
	if m != nil {
		return m.TransactionId
	}
	return nil
}

type GetTransResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *GetTransResponse) Reset()                    { *m = GetTransResponse{} }
func (m *GetTransResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTransResponse) ProtoMessage()               {}
func (*GetTransResponse) Descriptor() ([]byte, []int) { return fileDescriptorTccCoordinator, []int{12} }

func (m *GetTransResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func init() {
	proto.RegisterType((*TransactionId)(nil), "softtrans.contract.tcc_coordinator.TransactionId")
	proto.RegisterType((*TransactionStep)(nil), "softtrans.contract.tcc_coordinator.TransactionStep")
	proto.RegisterType((*Transaction)(nil), "softtrans.contract.tcc_coordinator.Transaction")
	proto.RegisterType((*BeginTransRequest)(nil), "softtrans.contract.tcc_coordinator.BeginTransRequest")
	proto.RegisterType((*BeginTransResponse)(nil), "softtrans.contract.tcc_coordinator.BeginTransResponse")
	proto.RegisterType((*TryStepRequest)(nil), "softtrans.contract.tcc_coordinator.TryStepRequest")
	proto.RegisterType((*TryStepResponse)(nil), "softtrans.contract.tcc_coordinator.TryStepResponse")
	proto.RegisterType((*ConfirmTransRequest)(nil), "softtrans.contract.tcc_coordinator.ConfirmTransRequest")
	proto.RegisterType((*ConfirmTransResponse)(nil), "softtrans.contract.tcc_coordinator.ConfirmTransResponse")
	proto.RegisterType((*CancelTransRequest)(nil), "softtrans.contract.tcc_coordinator.CancelTransRequest")
	proto.RegisterType((*CancelTransResponse)(nil), "softtrans.contract.tcc_coordinator.CancelTransResponse")
	proto.RegisterType((*GetTransRequest)(nil), "softtrans.contract.tcc_coordinator.GetTransRequest")
	proto.RegisterType((*GetTransResponse)(nil), "softtrans.contract.tcc_coordinator.GetTransResponse")
	proto.RegisterEnum("softtrans.contract.tcc_coordinator.Transaction_TransactionStatus", Transaction_TransactionStatus_name, Transaction_TransactionStatus_value)
}
func (m *TransactionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	if len(m.BusCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(len(m.BusCode)))
		i += copy(dAtA[i:], m.BusCode)
	}
	if len(m.TrxId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(len(m.TrxId)))
		i += copy(dAtA[i:], m.TrxId)
	}
	return i, nil
}

func (m *TransactionStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StepId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(len(m.StepId)))
		i += copy(dAtA[i:], m.StepId)
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTccCoordinator(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.TransactionId.Size()))
		n1, err := m.TransactionId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTccCoordinator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *BeginTransRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginTransRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.TransactionId.Size()))
		n2, err := m.TransactionId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *BeginTransResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginTransResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.Transaction.Size()))
		n3, err := m.Transaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *TryStepRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryStepRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.TransactionId.Size()))
		n4, err := m.TransactionId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.StepId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(len(m.StepId)))
		i += copy(dAtA[i:], m.StepId)
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTccCoordinator(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *TryStepResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryStepResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.Transaction.Size()))
		n5, err := m.Transaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.StepId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(len(m.StepId)))
		i += copy(dAtA[i:], m.StepId)
	}
	return i, nil
}

func (m *ConfirmTransRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmTransRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.TransactionId.Size()))
		n6, err := m.TransactionId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *ConfirmTransResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmTransResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.Transaction.Size()))
		n7, err := m.Transaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *CancelTransRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTransRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.TransactionId.Size()))
		n8, err := m.TransactionId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CancelTransResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTransResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.Transaction.Size()))
		n9, err := m.Transaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *GetTransRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TransactionId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.TransactionId.Size()))
		n10, err := m.TransactionId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *GetTransResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTccCoordinator(dAtA, i, uint64(m.Transaction.Size()))
		n11, err := m.Transaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeVarintTccCoordinator(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TransactionId) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	l = len(m.BusCode)
	if l > 0 {
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	l = len(m.TrxId)
	if l > 0 {
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *TransactionStep) Size() (n int) {
	var l int
	_ = l
	l = len(m.StepId)
	if l > 0 {
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			l = len(b)
			n += 1 + l + sovTccCoordinator(uint64(l))
		}
	}
	return n
}

func (m *Transaction) Size() (n int) {
	var l int
	_ = l
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovTccCoordinator(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovTccCoordinator(uint64(m.Status))
	}
	return n
}

func (m *BeginTransRequest) Size() (n int) {
	var l int
	_ = l
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *BeginTransResponse) Size() (n int) {
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *TryStepRequest) Size() (n int) {
	var l int
	_ = l
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	l = len(m.StepId)
	if l > 0 {
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			l = len(b)
			n += 1 + l + sovTccCoordinator(uint64(l))
		}
	}
	return n
}

func (m *TryStepResponse) Size() (n int) {
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	l = len(m.StepId)
	if l > 0 {
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *ConfirmTransRequest) Size() (n int) {
	var l int
	_ = l
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *ConfirmTransResponse) Size() (n int) {
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *CancelTransRequest) Size() (n int) {
	var l int
	_ = l
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *CancelTransResponse) Size() (n int) {
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *GetTransRequest) Size() (n int) {
	var l int
	_ = l
	if m.TransactionId != nil {
		l = m.TransactionId.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func (m *GetTransResponse) Size() (n int) {
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovTccCoordinator(uint64(l))
	}
	return n
}

func sovTccCoordinator(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTccCoordinator(x uint64) (n int) {
	return sovTccCoordinator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TransactionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, make([]byte, postIndex-iNdEx))
			copy(m.Args[len(m.Args)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &TransactionId{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &TransactionStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Transaction_TransactionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginTransRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginTransRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginTransRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &TransactionId{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginTransResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginTransResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginTransResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryStepRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryStepRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryStepRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &TransactionId{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, make([]byte, postIndex-iNdEx))
			copy(m.Args[len(m.Args)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryStepResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryStepResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryStepResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmTransRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmTransRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmTransRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &TransactionId{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmTransResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmTransResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmTransResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTransRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTransRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTransRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &TransactionId{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTransResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTransResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTransResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionId == nil {
				m.TransactionId = &TransactionId{}
			}
			if err := m.TransactionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTccCoordinator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTccCoordinator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTccCoordinator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTccCoordinator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTccCoordinator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTccCoordinator
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTccCoordinator
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTccCoordinator(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTccCoordinator = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTccCoordinator   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tcc_coordinator.proto", fileDescriptorTccCoordinator) }

var fileDescriptorTccCoordinator = []byte{
	// 549 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x3d, 0x8f, 0xd3, 0x40,
	0x10, 0xc5, 0x49, 0xee, 0x6b, 0x7c, 0xf9, 0xb8, 0xb9, 0x80, 0x2c, 0x4b, 0x44, 0x27, 0x57, 0xa9,
	0x8c, 0x70, 0x80, 0xa3, 0xa1, 0xb8, 0xb8, 0x40, 0x2e, 0x28, 0xf0, 0x05, 0x21, 0x68, 0x90, 0xcf,
	0xde, 0x0b, 0x86, 0x64, 0xd7, 0xac, 0x37, 0x08, 0x04, 0x42, 0xe2, 0x47, 0xf0, 0x9f, 0x28, 0xe9,
	0x69, 0x50, 0x7e, 0x05, 0x25, 0xf2, 0xc7, 0x29, 0xeb, 0xe4, 0xd0, 0xd9, 0x85, 0xd3, 0x65, 0x36,
	0x33, 0xef, 0xcd, 0x9b, 0x9d, 0xb7, 0x32, 0xdc, 0x16, 0xbe, 0xff, 0xc6, 0x67, 0x8c, 0x07, 0x21,
	0xf5, 0x04, 0xe3, 0x66, 0xc4, 0x99, 0x60, 0x68, 0xc4, 0xec, 0x52, 0x08, 0xee, 0xd1, 0xd8, 0xf4,
	0x19, 0x15, 0xdc, 0xf3, 0x85, 0xb9, 0x96, 0x69, 0xbc, 0x80, 0xf6, 0x24, 0xc9, 0xf0, 0x7c, 0x11,
	0x32, 0xea, 0x04, 0xd8, 0x87, 0x1d, 0x2f, 0x8a, 0x9c, 0x40, 0x53, 0x4e, 0x94, 0xe1, 0x81, 0x9b,
	0x05, 0xa8, 0xc1, 0xde, 0xc5, 0x22, 0xb6, 0x59, 0x40, 0xb4, 0x46, 0x7a, 0x7e, 0x15, 0x26, 0xf9,
	0x82, 0x7f, 0x72, 0x02, 0xad, 0x99, 0xe5, 0xa7, 0x81, 0xf1, 0x04, 0xba, 0x12, 0xec, 0xb9, 0x20,
	0x11, 0xde, 0x81, 0xdd, 0x58, 0x90, 0x15, 0x72, 0x1e, 0x21, 0x42, 0xeb, 0x8c, 0x4f, 0x63, 0xad,
	0x71, 0xd2, 0x1c, 0x1e, 0xba, 0xe9, 0x6f, 0xe3, 0x77, 0x03, 0x54, 0xa9, 0x1e, 0x5f, 0x42, 0x5b,
	0xc8, 0x5d, 0xa6, 0x10, 0xaa, 0x75, 0xdf, 0xbc, 0x59, 0xa1, 0x59, 0x90, 0xe7, 0x16, 0x71, 0xd0,
	0x81, 0x9d, 0xa4, 0x8d, 0x8c, 0x5d, 0xb5, 0x46, 0x15, 0x01, 0x13, 0x61, 0x6e, 0x86, 0x80, 0xaf,
	0x12, 0x7d, 0x9e, 0x58, 0xc4, 0xe9, 0x24, 0x3a, 0xd6, 0x59, 0x45, 0xac, 0x22, 0x6e, 0x02, 0xe4,
	0xe6, 0x80, 0xc6, 0x33, 0x38, 0xda, 0xf8, 0x13, 0xf7, 0xa1, 0xe5, 0xd0, 0x50, 0xf4, 0x6e, 0x61,
	0x1b, 0x0e, 0x6c, 0x36, 0x9f, 0x87, 0x42, 0x90, 0xa0, 0x07, 0xd8, 0x05, 0xd5, 0x65, 0xb3, 0x59,
	0x48, 0xa7, 0x63, 0xcf, 0x7f, 0xdf, 0xeb, 0x63, 0x07, 0x20, 0x39, 0x20, 0x41, 0x1a, 0x0f, 0x8d,
	0x19, 0x1c, 0x8d, 0xc9, 0x34, 0xa4, 0x29, 0xa6, 0x4b, 0x3e, 0x2c, 0x48, 0x2c, 0x6a, 0x1b, 0xb1,
	0x31, 0x05, 0x94, 0xd9, 0xe2, 0x88, 0xd1, 0x98, 0xe0, 0x73, 0x50, 0xa5, 0xb4, 0x9c, 0xec, 0x5e,
	0x45, 0x32, 0x57, 0xc6, 0x30, 0x7e, 0x28, 0xd0, 0x99, 0xf0, 0xcf, 0xe9, 0x9d, 0xd4, 0x2c, 0x4a,
	0x5a, 0xe6, 0xc6, 0xb5, 0xcb, 0xdc, 0x94, 0x96, 0xf9, 0x6b, 0xe2, 0x85, 0xbc, 0xad, 0xda, 0xd4,
	0xff, 0xaf, 0x23, 0x83, 0xc2, 0xb1, 0xcd, 0xe8, 0x65, 0xc8, 0xe7, 0xdb, 0xb9, 0xee, 0x10, 0xfa,
	0x45, 0xbe, 0xfa, 0x2e, 0x7c, 0x0e, 0x68, 0x7b, 0xd4, 0x27, 0xb3, 0xed, 0x28, 0x7b, 0x0b, 0xc7,
	0x05, 0xba, 0xfa, 0x84, 0xbd, 0x83, 0xee, 0x53, 0x22, 0xb6, 0xa3, 0x8a, 0x40, 0x6f, 0xc5, 0x55,
	0x9b, 0x24, 0xeb, 0x6f, 0x0b, 0x60, 0x62, 0xdb, 0xe7, 0x84, 0x7f, 0x0c, 0x7d, 0x82, 0x5f, 0x00,
	0x56, 0x8f, 0x02, 0x3e, 0x2c, 0x03, 0xbd, 0xf1, 0x64, 0xe9, 0x8f, 0xaa, 0x96, 0xe5, 0xf2, 0x38,
	0xec, 0xe5, 0x86, 0x44, 0xab, 0x9c, 0x28, 0xf9, 0x51, 0xd1, 0x47, 0x95, 0x6a, 0x72, 0xce, 0xef,
	0x0a, 0x1c, 0xca, 0xbe, 0xc0, 0xd3, 0x32, 0x28, 0xd7, 0x38, 0x57, 0x7f, 0x5c, 0xbd, 0x30, 0xef,
	0xe1, 0x1b, 0xa8, 0xd2, 0x02, 0x63, 0xa9, 0xf1, 0x6d, 0x1a, 0x4c, 0x3f, 0xad, 0x5c, 0x97, 0xf3,
	0x2f, 0x60, 0xff, 0x6a, 0xd5, 0xb0, 0xd4, 0x10, 0xd7, 0x4c, 0xa0, 0x3f, 0xa8, 0x56, 0x94, 0xd1,
	0x8e, 0xef, 0xfe, 0x5c, 0x0e, 0x94, 0x5f, 0xcb, 0x81, 0xf2, 0x67, 0x39, 0x50, 0x5e, 0x77, 0xd7,
	0xf2, 0x2f, 0x76, 0xd3, 0x8f, 0xa5, 0xd1, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x44, 0x4a, 0x22,
	0xee, 0x45, 0x09, 0x00, 0x00,
}
